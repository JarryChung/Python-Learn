# python_learn
Record learning python.

### 代码文件说明
+ python_1: 输入与输出,格式化
+ python_2: list,tuple,dict,set
+ python_3: 条件判断与循环
+ python_4: 函数(重点难点)
+ python_5: 高级特性
+ python_6: 函数式编程
+ python_7: 模块
+ python_8: 面向对象编程
+ python_9: 面向对象高级编程
+ python_10: 错误、调试和测试
+ python_11：I/O编程
+ python_12：进程和线程
+ python_13：正则表达式
+ python_14：
+ python_15
+ python_16
+ python_17
+ python_18

[toc]

### 语法
+ python不需要分号，采用换行以及缩进的形式。
+ 当语句以冒号:结尾时，下一行开始的缩进的语句视为代码块。
+ 字符串是以单引号'或双引号"括起来的任意文本，如果'本身也是一个字符，那就可以用""括起来。
+ 转义字符\可以转义很多字符，比如\n表示换行，\t表示制表符，字符\本身也要转义，所以\\\表示的字符就是\。
+ 如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用r''表示''内部的字符串默认不转义。
+ 空值是Python里一个特殊的值，用None表示。
+ 常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量。
+ python有两种除法：“/”结果为浮点数，“//”结果为整除。
+ int()函数发现一个字符串不是合法的数字时就会报错并退出。
+ 判断一个变量是否是某个类型可以用isinstance()判断。

### 各节需注意
#### python_1
+ python3.5中，print是一个函数，需要括号（）。
+ print()函数也可以接受多个字符串，用逗号“,”隔开，遇到逗号“,”会输出一个空格。
+ print()也可以打印整数，或者计算结果。
+ 输入使用input()方法，input()返回的数据类型是str。
+ python的格式化方式与c语言的一致。
+ 如果你不太确定应该用什么，**%s**永远起作用，它会把任何数据类型转换为字符串。

#### python_2
+ list
    + list是一种有序的集合，可以随时添加和删除其中的元素。
    + len()可以获得list中元素的个数。
    + 使用下标访问元素。
    + 添加元素用insert()方法，删除元素用pop()方法。
    + list里面的元素的数据类型可以不同,其元素可以是另一个list。
    + 如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素。
+ tuple
    + tuple和list非常类似，但是tuple一旦初始化就不能修改。
    + 只有1个元素的tuple定义时必须加一个逗号“,”，防止被当作小括号运算。
+ dict
    + Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。
    + dict内部存放的顺序和key放入的顺序是没有关系的。
    + 要删除一个key，用pop(key)方法，对应的value也会从dict中删除
    + **dict的key必须是不可变对象**
+ set
    + set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。
    + 通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果。
    + 通过remove(key)方法可以删除元素。
    + set显示的顺序也不表示set是有序的。
    + **set的key必须是不可变对象**
#### python_3
+ 条件判断
    + 注意不要少写了冒号“:”。
+ 循环
    + for x in ...循环就是把每个元素代入变量x，然后执行缩进块的语句。
    + range()函数可以生成一个整数序列，再通过list()函数可以转换为list。
    + while循环，只要条件满足，就不断循环，条件不满足时退出循环。
    + 在循环中，break语句可以提前退出循环。
    + 在循环过程中，也可以通过continue语句，跳过当前的这次循环，直接开始下一次循环。
    + 利用ctrl+c退出死循环。
#### python_4
+ 函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”。
+ 在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。
+ pass为占位符，为了方便以后添加执行语句。
+ python函数可以返回多个值，其实就是一个tuple。
+ 在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。
+ 函数在定义时可以设置默认参数，需从右到左含有。
+ **定义默认参数要牢记一点：默认参数必须指向不变对象！**
+ 当不按顺序提供部分默认参数时，需要把参数名写上。比如调用enroll('Adam', 'M', city='Tianjin')n。
+ 定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。
+ *nums表示把nums这个list的所有元素作为可变参数传进去。
+ 注意定义可变参数和关键字参数的语法：
    + *args是可变参数，args接收的是一个tuple
    + **kw是关键字参数，kw接收的是一个dict。
+ 定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。
+ 如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。
+ 命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错。
+ **难以理解的是，有关键字参数以及命名关键字参数的函数被调用后会输出None。**
+ 递归函数：如果一个函数在内部调用自身本身，这个函数就是递归函数。
    + 尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。
#### python_5
+ 切片
    + 可用于list & tuple & string
    + L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。
    + 如果第一个索引是0，可以省略。
    + 第3个参数为切片的间隔。
+ 迭代
    + 在Python中，迭代是通过for ... in来完成的。
    + Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。
    + 当我们使用for循环时，只要作用于一个可迭代对象，for循环就可以正常运行，而我们不太关心该对象究竟是list还是其他数据类型。
    + Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身。
+ 列表生成式
    + 列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。
    + for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value。
+ 生成器
    + 将列表生成式的[]换成（）则可。
    + 如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator。
    + 用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中。
    + generator，在执行过程中，遇到yield就中断，下次又继续执行。
+ 迭代器
    + 可以直接作用于for循环的对象统称为可迭代对象：Iterable。
    + 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。
    + 生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator，把list、dict、str等Iterable变成Iterator可以使用iter()函数。
    + 为什么list、dict、str等数据类型不是Iterator？这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。
    + 凡是可作用于for循环的对象都是Iterable类型，凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列。
    + Python的for循环本质上就是通过不断调用next()函数实现的。
#### python_6
+ 函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！
+ 高阶函数
    + 变量可以指向函数。
    + 函数名也是变量。
    + 传入函数：一个函数可以接收另一个函数作为参数，这种函数就称之为高阶函数。
+ map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。
+ reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。
+ 和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。
+ filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。
+ Python内置的sorted()函数就可以对list进行排序。
+ 高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。
    + **返回函数**
    + 即使拥有相同的参数，每次调用函数时都会返回新的函数。
    + 返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。
    + 返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。
    + **匿名函数**
    + 匿名函数```lambda x: x * x```：关键字lambda表示匿名函数，冒号前面的x表示函数参数。
    + 匿名函数限制：就是只能有一个表达式，不用写return，返回值就是该表达式的结果。
    + 匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数，也可以把匿名函数作为返回值返回。
    + **装饰器**
    + 通过``func.__name__``，可以拿到函数的名字。
    + 在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator），本质上，decorator就是一个返回函数的高阶函数。
    + **偏函数**
    + ```functools.partial```是帮助我们创建一个偏函数的,典型用法：```int2 = functools.partial(int, base=2)```。
    + 简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。
    + 当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。
#### python_7
+ 每一个包目录下面都会有一个__init__.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。__init__.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块，而它的模块名就是mycompany。
+ 任何模块代码的第一个字符串都被视为模块的文档注释。
+ 注意模块文件的编写格式。
+ **作用域**
    + 正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等。
    + 类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，__abc等。
#### python_8
+ 面向对象的设计思想是抽象出Class，根据Class创建Instance，数据封装、继承和多态是面向对象的三大特点。
+ 类和实例
    + 面向对象最重要的概念就是类（Class）和实例（Instance）。
    + 在Python中，定义类是通过class关键字，class后面紧接着是类名，紧接着是(object)，表示该类是从哪个类继承下来的，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。
    + 注意到__init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。
    + 有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数。
    + 通过类的方法实现数据封装。
+ 访问限制
    + 如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。
    + 需要访问限制的内容都可以在前面加上两个下划线```__```。
    + 有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。
    + 双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量。
+ 继承和多态
    + 在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。
    + 在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。
    + 对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。
    + 对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了。
+ 获取对象信息
    + 使用type()函数来判断对象类型。
    + 可以使用isinstance()函数判断class的类型。
    + 总是优先使用isinstance()判断类型，可以将指定类型及其子类“一网打尽”。
    + 如果要获得一个对象的所有属性和方法，可以使用dir()函数。
    + 自己写的类，如果也想用len(myObj)的话，就自己写一个__len__()方法。
    + 配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态。
    + 试图获取不存在的属性，会抛出AttributeError的错误。
+ 实例属性和类属性
    + 不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。
    + 类属性可以被所有该类的实例访问。
#### python_9
+ 讨论多重继承、定制类、元类等概念。
+ 使用__slots__
    + 正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。
    + 给一个实例绑定的方法，对另一个实例是不起作用的。
    + 为了给所有实例都绑定方法，可以给class绑定方法。
    + 为了达到限制属性的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性。
    + 子类实例允许定义的属性就是自身的__slots__加上父类的__slots__。
+ 使用@property
    + 在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把属性值随便改。
    + Python内置的@property装饰器负责把一个方法变成属性来调用。
+ 多重继承
    + 在设计类的继承关系时，通常，主线都是单一继承下来的，如果需要“混入”额外的功能，通过多重继承就可以实现，这种设计通常称之为MixIn。
    + MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。
+ 定制类
    + 直接显示变量调用的不是__str__()，而是__repr__()，两者的区别是__str__()返回用户看到的字符串，而__repr__()返回程序开发者看到的字符串，也就是说，__repr__()是为调试服务的。
    + 如果一个类想被用于for ... in循环，类似list或tuple那样，就必须实现一个__iter__()方法，该方法返回一个迭代对象。
    + Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。
    + __getattr__()方法:当调用不存在的属性时，比如score，Python解释器会试图调用__getattr__(self, 'score')来尝试获得属性，动态返回一个属性。
    + 只有在没有找到属性的情况下，才调用__getattr__，已有的属性，比如name，不会在__getattr__中查找。
    + 任何类，只需要定义一个__call__()方法，就可以直接对实例进行调用。
+ 使用枚举类
    + Enum:``Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))``定义了Month类型的枚举类，可以直接使用Month.Jan来引用一个常量，或者枚举它的所有成员。
+ 使用元类metaclass
    + 通过type()函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建出class。
    + type()函数既可以返回一个对象的类型，又可以创建出新的类型。
    + 要创建一个class对象，type()函数依次传入3个参数：
        + class的名称；
        + 继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；
        + class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。
    + 先定义metaclass，就可以创建类，最后创建实例。metaclass允许你创建类或者修改类。换句话说，你可以把类看成是metaclass创建出来的“实例”。
#### python_10
+ 错误处理
    + python内置了一套try...except...finally...的错误处理机制。
    + 当我们认为某些代码可能会出错时，就可以用try来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即except语句块，执行完except后，如果有finally语句块，则执行finally语句块，至此，执行完毕。
    + 由于没有错误发生，所以except语句块不会被执行，但是finally如果有，则一定会被执行（可以没有finally语句）。
    + 可以有多个except来捕获不同类型的错误。
    + 如果没有错误发生，可以在except语句块后面加一个else，当没有错误发生时，会自动执行else语句。
    + 所有的错误类型都继承自BaseException，所以在使用except时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。
    + 如果不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束了。既然我们能捕获错误，就可以把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去。
    + Python内置的logging模块可以非常容易地记录错误信息。
    + 因为错误是class，捕获一个错误就是捕获到该class的一个实例。用raise语句抛出一个错误的实例。
+ 调试
    + 凡是用print()来辅助查看的地方，都可以用断言（assert）来替代。
    + 启动Python解释器时可以用-O参数来关闭assert，关闭后，可以把所有的assert语句当成pass来看。
    + 把print()替换为logging是第3种方式，和assert比，logging不会抛出错误，而且可以输出到文件，logging.info()就可以输出一段文本。
+ 单元测试
    + 单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。
    + 以测试为驱动的开发模式最大的好处就是确保一个程序模块的行为符合我们设计的测试用例。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的。
    + 为了编写单元测试，我们需要引入Python自带的unittest模块。
+ 文档测试
#### python_11
+ 分为同步以及异步（这里主要是讨论同步）
+　文件读写
    + 在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。
    + 调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。
    + 调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。
    + 要读取二进制文件，比如图片、视频等等，用'rb'模式打开文件即可。
    + 要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数。
    + 在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，open()函数还接收一个errors参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略。
    +  写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符'w'或者'wb'表示写文本文件或写二进制文件。
    + 可以反复调用write()来写入文件，但是务必要调用f.close()来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。
    + 如果文件已存在，会直接覆盖（相当于删掉后新写入一个文件）。可以传入'a'以追加（append）模式写入。
    + 使用with语句操作文件IO是个好习惯。
+ StringIO和BytesIO
    + StringIO顾名思义就是在内存中读写str。
    + StringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。BytesIO实现了在内存中读写bytes。
+ 操作文件和目录
    + 注意uname()函数在Windows上不提供，也就是说，os模块的某些函数是跟操作系统相关的。
    + 在操作系统中定义的环境变量，全部保存在os.environ这个变量中，可以直接查看。
    + 把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数，这样可以正确处理不同操作系统的路径分隔符。
    + 要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名。
    + 这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。
    + ```os.rename('test.txt', 'test.py')```对文件重命名。
    + ```os.remove('test.py')```删掉文件。
+ 序列化
    + 把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling。
    + 把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。
    + Python内置的json模块提供了非常完善的Python对象到JSON格式的转换。
    + 把JSON反序列化为Python对象，用loads()或者对应的load()方法，前者把JSON的字符串反序列化，后者从file-like Object中读取字符串并反序列化。
    + JSON标准规定JSON编码是UTF-8，所以我们总是能正确地在Python的str与JSON的字符串之间转换。
#### python_12
+ 多任务的实现有3种方式:多进程模式；多线程模式；多进程+多线程模式。
+ 多进程
    + 进程间通信是通过Queue、Pipes等实现的。
    + multiprocessing模块就是跨平台版本的多进程模块，multiprocessing模块提供了一个Process类来代表一个进程对象。
+ 多线程
    + Python的标准库提供了两个模块：_thread和threading，_thread是低级模块，threading是高级模块，对_thread进行了封装。
    + 启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行。
    + 多线程编程，模型复杂，容易发生冲突，必须用锁加以隔离，同时，又要小心死锁的发生。
    + Python解释器由于设计时有GIL全局锁，导致了多线程无法利用多核。
+ 一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题。
+ 在Thread和Process中，应当优选Process，因为Process更稳定，而且，Process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上。
+ 


    
    

### 篇章标题
+ 注意小点
> 单行代码

### page2

**impotant**  
dafewfew
fesfewf  
fd

```python
print("代码")
```

***